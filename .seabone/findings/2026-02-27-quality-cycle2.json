[
  {
    "id": "quality-c2-1",
    "severity": "critical",
    "category": "quality",
    "file": "app/services/email.py",
    "line": 67,
    "issue": "SMTP server object is created inside a try block but server.quit() is only called on the success path (line 80); any exception after connection creation leaks the socket until OS timeout.",
    "task": "Wrap the SMTP connection in a try/finally block (or use contextlib.closing) so server.quit() is always called regardless of exceptions.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-2",
    "severity": "critical",
    "category": "quality",
    "file": "tests/test_api_scheduler.py",
    "line": 185,
    "issue": "test_refresh_schedule and test_enqueue_scheduled_task accept HTTP 500 as a valid passing response (lines 185, 193), masking real Celery infrastructure errors in CI.",
    "task": "Mock the Celery broker in tests so these endpoints reliably return 200/202, then assert the exact expected status code.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-3",
    "severity": "high",
    "category": "quality",
    "file": "app/services/notification.py",
    "line": 61,
    "issue": "Notifications.mark_read() calls db.get() inside a loop over notification_ids, issuing one SELECT per ID instead of a single IN-clause query (N+1 pattern).",
    "task": "Replace the loop with db.query(Notification).filter(Notification.id.in_([coerce_uuid(nid) for nid in notification_ids])).all() and then bulk-update the results.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-4",
    "severity": "high",
    "category": "quality",
    "file": "app/tasks/notifications.py",
    "line": 8,
    "issue": "Both Celery tasks (dispatch_notifications, send_notification_email) have no retry configuration; a transient broker or DB failure silently drops notifications with no recovery mechanism.",
    "task": "Add max_retries and default_retry_delay to both @celery_app.task decorators and call self.retry(exc=e) inside the exception handler.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-5",
    "severity": "high",
    "category": "quality",
    "file": "tests/test_api_auth_flow.py",
    "line": 62,
    "issue": "Seven test assertions use status_code in [401, 404], allowing the wrong error code (e.g. 404 returned when 401 was expected) to silently pass.",
    "task": "Determine the exact expected status code for each case and assert it directly; separate tests for not-found vs unauthorised if both paths must be covered.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-6",
    "severity": "high",
    "category": "quality",
    "file": "app/tasks/search.py",
    "line": 37,
    "issue": "reindex_all_documents loads all active documents into memory at once via .all(), which will exhaust memory when the document table is large.",
    "task": "Rewrite to process documents in batches using offset/limit pagination or yield_per(), processing and committing each batch separately.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-7",
    "severity": "medium",
    "category": "quality",
    "file": "app/services/audit.py",
    "line": 10,
    "issue": "_apply_ordering and _apply_pagination are copied verbatim across 6 service files (audit, auth, domain_settings, person, rbac, scheduler) even though app.services.common already exports the same functions as apply_ordering/apply_pagination.",
    "task": "Delete the local _apply_ordering/_apply_pagination definitions in each of the 6 files and import apply_ordering, apply_pagination from app.services.common instead.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-8",
    "severity": "medium",
    "category": "quality",
    "file": "app/api/auth_flow.py",
    "line": 380,
    "issue": "list_sessions endpoint queries all active sessions for a user without any limit parameter, returning an unbounded result set for users with many historical sessions.",
    "task": "Add limit/offset query parameters to list_sessions and apply them to the query; default limit to 50 or similar.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-9",
    "severity": "medium",
    "category": "quality",
    "file": "tests/conftest.py",
    "line": 131,
    "issue": "The db_session fixture yields a session that is only closed (not rolled back) in the finally block; rows committed by one test persist in the shared module-scoped in-memory SQLite engine, causing state leakage between tests.",
    "task": "Add session.rollback() before session.close() in the fixture's finally block so all test mutations are undone after each test function.",
    "auto_fixable": true,
    "effort": "small"
  },
  {
    "id": "quality-c2-10",
    "severity": "medium",
    "category": "quality",
    "file": "app/services/ecm_folder.py",
    "line": 118,
    "issue": "_compute_path silently falls back to returning the folder's own name as a root path when its declared parent_id does not resolve, masking orphaned-folder data corruption.",
    "task": "Log a warning (or raise an HTTPException) when parent lookup fails in _compute_path so callers are notified of the inconsistency.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-11",
    "severity": "medium",
    "category": "quality",
    "file": "app/api/auth_flow.py",
    "line": 338,
    "issue": "upload_avatar has no try/except around the await avatar_service.save_avatar() call; any file-service error (disk full, permission denied, bad MIME type) propagates as an unhandled 500.",
    "task": "Wrap save_avatar() in try/except and raise HTTPException(400) for user-fixable errors (oversized/invalid file) and re-raise or return 500 with a structured error body for infrastructure failures.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-12",
    "severity": "medium",
    "category": "quality",
    "file": "app/api/search.py",
    "line": 42,
    "issue": "The search endpoint returns count=len(items) which equals the current page size (at most limit), not the total number of matching documents, making pagination metadata incorrect.",
    "task": "Execute a separate .count() query before applying pagination and return it as total_count (or count); rename the field to avoid confusion with page count.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-13",
    "severity": "medium",
    "category": "quality",
    "file": "tests/test_api_ecm_acl.py",
    "line": 65,
    "issue": "TestDocumentACLEndpoints only tests successful ACL creation; there are no tests verifying that unauthorized requests receive 403 Forbidden, leaving ACL enforcement untested.",
    "task": "Add test cases that make ACL requests without auth headers or with a user lacking permission and assert the response is 401/403.",
    "auto_fixable": false,
    "effort": "medium"
  },
  {
    "id": "quality-c2-19",
    "severity": "medium",
    "category": "quality",
    "file": "app/tasks/retention.py",
    "line": 37,
    "issue": "check_retention_expiry() calls db.commit() inside the per-record for-loop, issuing N separate database round-trips when a single commit after the loop would suffice.",
    "task": "Move db.commit() outside the for-loop and collect all updated retention objects; commit once after all status updates, then refresh each object.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-20",
    "severity": "medium",
    "category": "quality",
    "file": "app/tasks/retention.py",
    "line": 24,
    "issue": "check_retention_expiry() loads all eligible DocumentRetention records with .all() into memory before processing, causing unbounded RAM growth when many records are past their expiry date.",
    "task": "Rewrite to process expired retentions in batches using .limit()/.offset() pagination (same pattern as quality-c2-6 for search), committing and refreshing each batch before continuing.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-21",
    "severity": "medium",
    "category": "quality",
    "file": "app/tasks/webhooks.py",
    "line": 47,
    "issue": "_find_and_queue() loads all active webhook endpoints with .all() into memory before filtering by event_type match, causing unbounded memory use as the number of configured endpoints grows.",
    "task": "Push the event_type filter into the database query using a JSON contains or array-overlap operator, or paginate endpoint fetching so only matching endpoints are loaded at once.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-14",
    "severity": "low",
    "category": "quality",
    "file": "tests/test_ecm_acl_services.py",
    "line": 23,
    "issue": "_make_person, _make_document, and _make_folder helper functions are defined inline and duplicate the person/document/folder fixtures already available in conftest.py.",
    "task": "Remove the local helper functions and inject the corresponding conftest.py fixtures (person, document, folder) via function parameters instead.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-15",
    "severity": "low",
    "category": "quality",
    "file": "tests/test_api_ecm_acl.py",
    "line": 13,
    "issue": "_create_person, _create_document, and _create_folder helpers duplicate conftest.py fixtures with slightly different naming, creating two sources of truth for test object creation.",
    "task": "Replace module-level helper calls with conftest.py fixture injections (person, db_session) to eliminate the duplication.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-16",
    "severity": "low",
    "category": "quality",
    "file": "app/services/notification.py",
    "line": 37,
    "issue": "The list() method return type annotation uses the legacy typing.List[Notification] instead of the modern built-in list[Notification] (Python 3.9+).",
    "task": "Replace List[Notification] with list[Notification] and remove the unused List import from typing.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-17",
    "severity": "low",
    "category": "quality",
    "file": "tests/test_event_services.py",
    "line": 13,
    "issue": "test_event_type_count asserts len(EventType) == 25, making the test fail whenever a new event type is legitimately added to the enum.",
    "task": "Remove the hardcoded count assertion or replace it with a looser lower-bound check (assert len(EventType) >= 25) that tolerates additions.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-22",
    "severity": "low",
    "category": "quality",
    "file": "app/api/ecm_documents.py",
    "line": 24,
    "issue": "An identical get_db() generator (try/yield/commit/rollback/close) is defined in 18 separate API router files (persons, auth_flow, rbac, audit, settings, scheduler, ecm_folders, ecm_documents, ecm_metadata, ecm_acl, ecm_checkouts, ecm_workflows, ecm_collaboration, ecm_retention, ecm_legal_holds, notifications, webhooks, search), creating 18-way code duplication of the same pattern.",
    "task": "Move the shared get_db() implementation to app/db.py (or app/api/deps.py) and import it in each router file, eliminating the duplication.",
    "auto_fixable": false,
    "effort": "small"
  },
  {
    "id": "quality-c2-23",
    "severity": "low",
    "category": "quality",
    "file": "app/services/ecm_checkout.py",
    "line": 44,
    "issue": "checkout() calls db.flush() at line 38 (inside the try block) and again at line 44 (after the except handler), making the second call a redundant no-op that adds unnecessary DB round-trip overhead.",
    "task": "Remove the redundant db.flush() at line 44; the flush inside the try block is sufficient and the subsequent db.refresh(checkout) does not require another flush.",
    "auto_fixable": true,
    "effort": "trivial"
  },
  {
    "id": "quality-c2-18",
    "severity": "low",
    "category": "quality",
    "file": "app/services/auth_flow.py",
    "line": 436,
    "issue": "The login() method handles four distinct concerns in sequence (provider resolution, credential lookup, account lockout, MFA check) making it harder to test and maintain each concern independently.",
    "task": "Extract lockout check and MFA check into private helper methods (_check_lockout, _check_mfa_required) to keep login() as an orchestrator under 30 lines.",
    "auto_fixable": false,
    "effort": "small"
  }
]
